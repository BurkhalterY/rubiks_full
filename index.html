<!DOCTYPE html>
<html>
	<head>
		<title>Rubik'S</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<style>
			body {
				margin: 0;
			}
			canvas {
				display: block;
			}
			#form {
				position: absolute;
				width: 200px;
				height: 200px;
				top: 0;
				right: 0;
			}
			#algorithm {
				background-color: white;
				white-space: pre-wrap;
				white-space: -moz-pre-wrap;
				white-space: -o-pre-wrap;
				word-wrap: break-word;
			}
			#current {
				color: red;
			}
		</style>
	</head>
	<body>
		<div id="form">
			<input type="text" id="input">
			<button id="btn-ok">O.K.</button>
			<pre id="algorithm"></pre>
			<button id="btn-first">&laquo;</button>
			<button id="btn-prec">&lt;</button>
			<button id="btn-next">&gt;</button>
			<button id="btn-last">&raquo;</button>
		</div>
		<script type="module">
			import * as THREE from './three.js-master/build/three.module.js';
			import { OrbitControls as TrackballControls } from './three.js-master/examples/jsm/controls/OrbitControls.js';

			const axis = {
				right: new THREE.Vector3(-1, 0, 0),
				left: new THREE.Vector3(1, 0, 0),
				up: new THREE.Vector3(0, -1, 0),
				down: new THREE.Vector3(0, 1, 0),
				front: new THREE.Vector3(0, 0, -1),
				back: new THREE.Vector3(0, 0, 1)
			};

			const white = 0xffffff;
			const red = 0xff0000;
			const yellow = 0xffff00;
			const orange = 0xff8800;
			const green = 0x008800;
			const blue = 0x0000ff;
			const black = 0x000000;
			const grey = 0x999999;

			const loader = new THREE.TextureLoader();
			const whiteMat = new THREE.MeshBasicMaterial({map: loader.load('./textures/white.png')});
			const redMat = new THREE.MeshBasicMaterial({map: loader.load('./textures/red.png')});
			const yellowMat = new THREE.MeshBasicMaterial({map: loader.load('./textures/yellow.png')});
			const orangeMat = new THREE.MeshBasicMaterial({map: loader.load('./textures/orange.png')});
			const greenMat = new THREE.MeshBasicMaterial({map: loader.load('./textures/green.png')});
			const blueMat = new THREE.MeshBasicMaterial({map: loader.load('./textures/blue.png')});
			const blackMat = new THREE.MeshBasicMaterial({map: loader.load('./textures/black.png')});
			const greyMat = new THREE.MeshBasicMaterial({map: loader.load('./textures/grey.png')});

			const mat = new THREE.MeshBasicMaterial({ vertexColors: true });
			const transparentMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });

			const urlParams = new URLSearchParams(window.location.search);

			const embed = urlParams.has('embed');

			const width = urlParams.has('width') ? urlParams.get('width') : 3;
			const height = urlParams.has('height') ? urlParams.get('height') : width;
			const depth = urlParams.has('depth') ? urlParams.get('depth') : width;
			const longest = Math.max(width, height, depth);
			const type = urlParams.has('type') ? urlParams.get('type') : 'cube';

			var colors = {};

			const min = { x: -(width-1)/2, y: -(height-1)/2, z: -(depth-1)/2 };
			const max = { x: (width-1)/2, y: (height-1)/2, z: (depth-1)/2 };

			const speed = 8;

			var scene, camera, renderer, controls;

			var algorithm = [];
			var algorithmIndex = 0;
			var algoReverse = true;

			var keys = {};
			var acutalIndice = '';
			var keysActive = true;

			var cubes = [];

			var queue = [];
			var shots = [];

			init();
			animate();

			function init() {
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
				camera.position.copy(new THREE.Vector3(longest * 2, longest * 2, longest * 2));

				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0x333333);
				document.body.appendChild(renderer.domElement);

				controls = new TrackballControls(camera, renderer.domElement);
				/*controls.noPan = true;
				controls.noZoom = true;
				controls.rotateSpeed = 5;*/

				switch(type) {
					case 'cube':
						generateCube();
						break;
					case 'pyraminx':
						generatePyraminx();
						break;
				}
			}

			function generateCube() {

				if(urlParams.has('colors')){

					colors = { 'U': [], 'R': [], 'F': [], 'L': [], 'B': [], 'D': [] };
					let colors2 = JSON.parse(urlParams.get('colors'));

					for (let face of 'URFLBD') {
						if(colors2.hasOwnProperty(face)){
							for (let i = 0; i < width * height; i++) {
								if(colors2[face].hasOwnProperty(i)){
									colors[face].push(colors2[face][i]);
								} else {
									colors[face].push('-');
								}
							}
						} else {
							for (let i = 0; i < width * height; i++) {
								colors[face].push('-');
							}
						}
					}
				} else {
					colors = {
						'U': ['w'],
						'R': ['r'],
						'F': ['g'],
						'L': ['o'],
						'B': ['b'],
						'D': ['y']
					};
					for (let face of 'URFLBD') {
						for (let i = 1; i < width * height; i++) {
							colors[face].push(colors[face][0]);
						}
					}
				}

				keys.X = { zones: [], axis: axis.right };
				keys.Y = { zones: [], axis: axis.up };
				keys.Z = { zones: [], axis: axis.front };

				for (let x = min.x; x <= max.x; x++) {
					let box = new THREE.BoxGeometry(0.1, longest, longest);
					let zone = new THREE.Mesh(box, transparentMat);

					zone.position.x = x;

					let key = toNotation(x, min.x, max.x, 'R', 'L', 'M');
					keys[key] = { zones: [zone], axis: key.startsWith('R') ? axis.right : axis.left };
					keys.X.zones.push(zone);

					scene.add(zone);
				}
				for (let y = min.y; y <= max.y; y++) {
					let box = new THREE.BoxGeometry(longest, 0.1, longest);
					let zone = new THREE.Mesh(box, transparentMat);

					zone.position.y = y;

					let key = toNotation(y, min.y, max.y, 'U', 'D', 'E');
					keys[key] = { zones: [zone], axis: key.startsWith('U') ? axis.up : axis.down };
					keys.Y.zones.push(zone);

					scene.add(zone);
				}
				for (let z = min.z; z <= max.z; z++) {
					let box = new THREE.BoxGeometry(longest, longest, 0.1);
					let zone = new THREE.Mesh(box, transparentMat);

					zone.position.z = z;

					let key = toNotation(z, min.z, max.z, 'F', 'B', 'S');
					keys[key] = { zones: [zone], axis: key.startsWith('B') ? axis.back : axis.front };
					keys.Z.zones.push(zone);

					scene.add(zone);
				}

				let i = 0;
				for (let x = min.x; x <= max.x; x++) {
					for (let y = min.y; y <= max.y; y++) {
						for (let z = min.z; z <= max.z; z++) {
							if(x == min.x || x == max.x || y == min.y || y == max.y || z == min.z || z == max.z){
								let box = new THREE.BoxGeometry();
								let materials = [];
								//for (let j = 0; j < box.faces.length; j++) {
								for (let j = 0; j < 6; j++) {
									//box.faces[j].color.set(getColor(Math.floor(j/2), x, y, z));
									materials.push(getColor(Math.floor(j), x, y, z));
								}

								let cube = new THREE.Mesh(box, materials);
							
								cube.position.copy(new THREE.Vector3(x, y, z));

								scene.add(cube);
								cubes[i++] = cube;
							}
						}
					}
				}
			}

			function generatePyraminx() {
				let h = 4/3;
				let a = 4/Math.sqrt(6);
				let l = Math.sqrt(2);
				let r = a / 2 * Math.sqrt(2);

				let avg = new THREE.Vector3();
				let nb = 0;

				//keys.X = { zones: [], axis: axis.right };
				//keys.Y = { zones: [], axis: axis.up };
				//keys.Z = { zones: [], axis: axis.front };

				let i = 0;
				for (let y = max.y; y >= min.y; y--) {
					for (let x = max.x; x >= y; x--) {
						for (let z = max.z; z >= x; z--) {
							let box = new THREE.TetrahedronGeometry();
							box.applyMatrix4(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, -1).normalize(), Math.atan(Math.sqrt(2))));
							box.applyMatrix4(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0).normalize(), Math.PI/4));

							for (let j = 0; j < box.faces.length; j++) {
								box.faces[j].color.set(/*getColorTetrahedron(j, x, y, z)*/Math.random()*0xffffff);
							}

							let cube = new THREE.Mesh(box, mat);

							cube.position.y = y * h;
							cube.position.x = (x - (max.x + y * h)/2) * l;
							cube.position.z = (z - (max.z + x)/2) * a;

							avg.add(cube.position);
							nb++;

							scene.add(cube);
							cubes[i++] = cube;
						}
					}
				}

				/*for (let y = max.y; y >= min.y + 1; y--) {
					for (let x = max.x; x >= y; x--) {
						for (let z = max.z; z >= x; z--) {
							let box = new THREE.OctahedronGeometry(r);
							box.applyMatrix4(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, -1).normalize(), Math.atan(Math.sqrt(2))));
							box.applyMatrix4(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0).normalize(), Math.PI/4));
							
							let cube = new THREE.Mesh(box, mat);

							cube.position.y = y * h - 1;
							cube.position.x = (x - (max.x + y * h)/2) * l;
							cube.position.z = (z - (max.z + x)/2) * a;

							scene.add(cube);
							cubes[i++] = cube;
						}
					}
				}*/

				avg.divideScalar(nb);

				let box = new THREE.TetrahedronGeometry(longest);
				box.applyMatrix4(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, -1).normalize(), Math.atan(Math.sqrt(2))));
				box.applyMatrix4(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0).normalize(), Math.PI/4));
				let full = new THREE.Mesh(box, transparentMat);
				full.position.copy(avg);

				scene.add(full);

				let pos = [];

				for (let j = 0; j < /*box.faces.length*/1; j++) {
					//let box2 = new THREE.BoxGeometry(0.1, 0.1, a * longest);
					let box2 = new THREE.BoxGeometry(a * longest, a * longest, 0.1);
					box2.lookAt(box.faces[j].normal);
					//box2.applyMatrix4(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0).normalize(), Math.PI/2));
					let zone = new THREE.Mesh(box2, transparentMat);

					zone.position.copy(full.position);

					//let key = toNotation(x, min.x, max.x, 'R', 'L', 'M');
					//keys['a'+Math.round(Math.random()*1000)] = { zones: [zone], axis: box2.faces[j].normal };
					;
					//keys.X.zones.push(zone);
					pos.push({ zones: [zone], axis: box2.faces[j].normal });

					scene.add(zone);
				}
				keys['U'] = pos[0];
				keys['D'] = pos[1];
				keys['L'] = pos[2];
				keys['R'] = pos[3];

				var axesHelper = new THREE.AxesHelper( 5 );
				scene.add( axesHelper );
			}

			function animate() {
				requestAnimationFrame(animate);
				executeQueue();
				controls.update();
				renderer.render(scene, camera);
			}

			function press(code, reverse = false) {
				if(code[0] == '#'){
					switch(code[1]){
						case '1':
							shots = [];
							for (let i = 0; i < 40; i++) {
								addToQueue(Object.values(keys).sample(), [1, -1, 2].sample(), false);
							}
							break;
						case '2':
							if(shots.length > 0){
								let shot = shots.pop();
								addToQueue(shot[0], -shot[1], false);
							}
							break;
					}
				} else {
					let direction = 1;
					if(code[code.length-1] == '\''){
						direction = -1;
						code = code.slice(0, -1);
					} else if(code[code.length-1] == '2'){
						direction = 2;
						code = code.slice(0, -1);
					}
					if(reverse){
						direction = -direction;
					}
					if(keys[code] !== undefined){
						addToQueue(keys[code], direction);
					}
				}
			}

			function addToQueue(key, direction, save = true) {
				let action = [];
				for(let zone of key.zones) {
					let group = new THREE.Group();
					scene.add(group);
					action.push({ zone: zone, direction: direction, axis: key.axis, i: 0, group: group });
				}
				if(save){
					shots.push([key, direction]);
				}
				queue.unshift(action);
			}

			function executeQueue() {
				if(queue.length > 0){
					let action = queue[queue.length-1];
					for(let singleAction of action) {

						let group = singleAction.group;
						group.position.copy(singleAction.zone.position);

						if(group.children.length == 0){

							for(let mesh of cubes) {
								mesh.geometry.computeBoundingBox();
								singleAction.zone.geometry.computeBoundingBox();
								mesh.updateMatrixWorld();
								singleAction.zone.updateMatrixWorld();

								let box1 = mesh.geometry.boundingBox.clone();
								box1.applyMatrix4(mesh.matrixWorld);

								let box2 = singleAction.zone.geometry.boundingBox.clone();
								box2.applyMatrix4(singleAction.zone.matrixWorld);

								if(box2.intersectsBox(box1)){
									group.attach(mesh);
								}
							}
						}

						group.rotateOnAxis(singleAction.axis, Math.PI/(type == 'pyraminx' ? 1.5 : 2) / speed * singleAction.direction);

						if(++singleAction.i >= speed){
							queue.pop();
						}
					}
				}
			}

			function updateAlgorithm() {
				let values = document.getElementById('input').value.split(' ');
				algorithm = [];
				for (let i = 0; i < values.length; i++) {
					if(values[i].length >= 1){
						let value = '';
						if('LRUDFBMESXYZ'.includes(values[i][0])){
							value = values[i][0];
							for (let j = 1; j < values[i].length-1; j++) {
								value += toIndice(values[i][j]);
							}
							if(values[i].length >= 2){
								if('\'2'.includes(values[i][values[i].length-1])){
									value += values[i][values[i].length-1];
								}
							}
						}
						algorithm.push(value);
					}
				}
				document.getElementById('algorithm').innerHTML = algorithm.join(' ');
				algorithmIndex = 0;
				algoReverse = true
			}

			function first() {
				for (let i = algorithmIndex; i >= 0; i--) {
					executeCode(true);
				}
			}

			function prec() {
				executeCode(true);
			}

			function next() {
				executeCode();
			}

			function last() {
				for (let i = algorithmIndex; i < algorithm.length; i++) {
					executeCode();
				}
			}

			function executeCode(reverse = false) {
				if(reverse && algorithmIndex > 0 || !reverse && algorithmIndex < algorithm.length-1 || algorithm.length == 1){
					if(reverse == algoReverse){
						algorithmIndex += reverse ? -1 : 1;
						algorithmIndex = Math.min(Math.max(algorithmIndex, 0), algorithm.length-1);
					}
					press(algorithm[algorithmIndex], reverse, false);
					let showAlgo = [...algorithm];
					showAlgo[algorithmIndex] = '<span id="current">'+showAlgo[algorithmIndex]+'</span>';
					document.getElementById('algorithm').innerHTML = showAlgo.join(' ');
				}
				algoReverse = reverse;
			}

			function toNotation(coord, min, max, charR, charL, charM) {
				if(coord > 0){
					return charR + toIndice(-min-coord+1);
				} else if(coord < 0){
					return charL + toIndice(max+coord+1);
				} else {
					return charM;
				}
			}

			function toIndice(number) {
				number += '';
				for (let i = 0; i <= 9; i++) {
					number = number.replaceAll(i, '₀₁₂₃₄₅₆₇₈₉'[i]);
				}
				if(number == '₁'){
					number = '';
				}
				return number;
			}

			function toColorCode(letter) {
				switch(letter) {
					case 'w':
						return whiteMat;
					case 'r':
						return redMat;
					case 'y':
						return yellowMat;
					case 'o':
						return orangeMat;
					case 'g':
						return greenMat;
					case 'b':
						return blueMat;
					case '_':
						return blackMat;
					case '-':
						return greyMat;
					default:
						return blackMat
				}
			}

			function getColor(face, x, y, z) {

				let a = x, b = y;
				let i = '-';

				if(face == 0 && x == max.x){
					i = 'R';
					a = z;
				} else if(face == 1 && x == min.x){
					i = 'L';
					a = z;
				} else if(face == 2 && y == max.y){
					i = 'U';
					b = z;
				} else if(face == 3 && y == min.y){
					i = 'D';
					b = z;
				} else if(face == 4 && z == max.z){
					i = 'F';
				} else if(face == 5 && z == min.z){
					i = 'B';
				} else {
					return toColorCode('');
				}
				return toColorCode(colors[i][(a + max.x) + (b + max.y) * width]);
			}

			function getColorTetrahedron(face) {
				if(face == 0){
					return green;
				}
				else if(face == 1){
					return red;
				}
				else if(face == 2){
					return blue;
				}
				else if(face == 3){
					return yellow;
				} else {
					return black;
				}
			}

			function getColorOctahedron(face) {
				if(face == 1){
					return blue;
				}
				else if(face == 3){
					return red;
				}
				else if(face == 5){
					return yellow;
				}
				else if(face == 7){
					return green;
				} else {
					return black;
				}
			}

			Array.prototype.sample = function(){
				return this[Math.floor(Math.random() * this.length)];
			}

			document.getElementById('btn-ok').addEventListener('click', updateAlgorithm);
			document.getElementById('btn-first').addEventListener('click', first);
			document.getElementById('btn-prec').addEventListener('click', prec);
			document.getElementById('btn-next').addEventListener('click', next);
			document.getElementById('btn-last').addEventListener('click', last);

			if(embed){
				document.getElementById('form').style.display = 'none';
			} else {

				document.getElementById('form').onkeydown = function (e) {
					keysActive = false;
				}

				document.getElementById('input').onblur = function (e) {
					keysActive = true;
				}

				document.body.onkeydown = function (e) {
					if(keysActive){
						let key = e.key.toUpperCase();
						if('LRUDFBMESXYZ'.includes(key)) {
							press(key + acutalIndice + (e.shiftKey ? '\'' : (e.ctrlKey ? '2' : '')));
						} else if('123456789'.includes(key)) {
							acutalIndice = toIndice(key);
						} else if(key == ' ') {
							press('#1');
						} else if(key == 'BACKSPACE') {
							press('#2');
						}
						return false;
					}
				};
			}

			window.onresize = function () {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);

				controls.handleResize();
			};
		</script>
	</body>
</html>