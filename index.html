<!DOCTYPE html>
<html>
	<head>
		<title>Rubik'S</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<style>
			body {
				margin: 0;
			}
			canvas {
				display: block;
			}
			#form {
				position: absolute;
				width: 100%;
				bottom: 0;
				right: 0;
			}
			#algorithm {
				background-color: white;
				white-space: pre-wrap;
				white-space: -moz-pre-wrap;
				white-space: -o-pre-wrap;
				word-wrap: break-word;
			}
			#current {
				color: red;
			}
		</style>
	</head>
	<body>
		<div id="form">
			<div id="form-hide">
				<input type="text" id="input">
				<button id="btn-ok">O.K.</button>
			</div>
			<button id="btn-first">&laquo;</button>
			<button id="btn-prec">&lt;</button>
			<button id="btn-next">&gt;</button>
			<button id="btn-last">&raquo;</button>
			<pre id="algorithm"></pre>
		</div>
		<script type="module">
			import * as THREE from './three.js-master/build/three.module.js';
			import { OrbitControls as TrackballControls } from './three.js-master/examples/jsm/controls/OrbitControls.js';

			const axis = {
				right: new THREE.Vector3(-1, 0, 0),
				left: new THREE.Vector3(1, 0, 0),
				up: new THREE.Vector3(0, -1, 0),
				down: new THREE.Vector3(0, 1, 0),
				front: new THREE.Vector3(0, 0, -1),
				back: new THREE.Vector3(0, 0, 1)
			};

			const white = 0xffffff;
			const red = 0xff0000;
			const yellow = 0xffff00;
			const orange = 0xff8800;
			const green = 0x008800;
			const blue = 0x0000ff;
			const black = 0x000000;
			const grey = 0x999999;

			const mat = new THREE.MeshBasicMaterial({ vertexColors: true });
			const transparentMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });

			const urlParams = new URLSearchParams(window.location.search);
			const embed = urlParams.has('embed');

			const width = urlParams.has('width') ? urlParams.get('width') : 3;
			const height = urlParams.has('height') ? urlParams.get('height') : width;
			const depth = urlParams.has('depth') ? urlParams.get('depth') : width;
			const longest = Math.max(width, height, depth);
			const type = urlParams.has('type') ? urlParams.get('type') : 'cube';

			const loader = new THREE.TextureLoader();
			const materialsColors = {
				'w': new THREE.MeshBasicMaterial({map: loader.load('./textures/w.png')}),
				'r': new THREE.MeshBasicMaterial({map: loader.load('./textures/r.png')}),
				'y': new THREE.MeshBasicMaterial({map: loader.load('./textures/y.png')}),
				'o': new THREE.MeshBasicMaterial({map: loader.load('./textures/o.png')}),
				'g': new THREE.MeshBasicMaterial({map: loader.load('./textures/g.png')}),
				'b': new THREE.MeshBasicMaterial({map: loader.load('./textures/b.png')}),
				'_': new THREE.MeshBasicMaterial({map: loader.load('./textures/_.png')}),
				'-': new THREE.MeshBasicMaterial({map: loader.load('./textures/-.png')})
			};

			var colors = {};

			const min = { x: -(width-1)/2, y: -(height-1)/2, z: -(depth-1)/2 };
			const max = { x: (width-1)/2, y: (height-1)/2, z: (depth-1)/2 };

			const speed = 8;

			var scene, camera, renderer, controls;

			var algorithm = [];
			var algorithmIndex = 0;
			var algoReverse = true;

			var keys = {};
			var acutalIndice = '';
			var keysActive = true;

			var cubes = [];

			var queue = [];
			var shots = [];

			init();
			animate();

			function init() {
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
				camera.position.copy(new THREE.Vector3(longest * 2, longest * 2, longest * 2));

				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0x333333);
				document.body.appendChild(renderer.domElement);

				controls = new TrackballControls(camera, renderer.domElement);
				/*controls.noPan = true;
				controls.noZoom = true;
				controls.rotateSpeed = 5;*/

				updateAlgorithm();

				switch(type) {
					case 'cube':
						generateCube();
						break;
				}
			}

			function generateCube() {

				if(urlParams.has('colors')){

					colors = { 'U': [], 'R': [], 'F': [], 'L': [], 'B': [], 'D': [] };
					let colors2 = JSON.parse(urlParams.get('colors'));

					for (let face of 'URFLBD') {
						if(colors2.hasOwnProperty(face)){
							for (let i = 0; i < colors2[face].length; i++) {
								colors[face].push('-');
								colors[face][i] = colors2[face][i];
							}
						}
					}
				} else {
					colors = {
						'U': ['w'],
						'R': ['r'],
						'F': ['g'],
						'L': ['o'],
						'B': ['b'],
						'D': ['y']
					};
					for (let face of 'URFLBD') {
						let l = width;
						let L = height;
						if('LR'.includes(face)){
							l = depth;
						} else if('UD'.includes(face)){
							L = depth;
						}
						for (let i = 1; i < l * L; i++) {
							colors[face].push(colors[face][0]);
						}
					}
				}

				keys.X = { zones: [], axis: axis.right };
				keys.Y = { zones: [], axis: axis.up };
				keys.Z = { zones: [], axis: axis.front };

				let xCoords = [];
				let yCoords = [];
				let zCoords = [];

				for (let x = min.x; x <= max.x; x++) {
					let zone = { cubes: [], center: new THREE.Vector3(), angle: Math.PI/2 };

					let key = toNotation(x, min.x, max.x, 'R', 'L', 'M');
					xCoords.push([x, zone]);
					keys[key] = { zones: [zone], axis: key.startsWith('R') ? axis.right : axis.left };
					keys.X.zones.push(zone);
				}
				for (let y = min.y; y <= max.y; y++) {
					let zone = { cubes: [], center: new THREE.Vector3(), angle: Math.PI/2 };

					let key = toNotation(y, min.y, max.y, 'U', 'D', 'E');
					yCoords.push([y, zone]);
					keys[key] = { zones: [zone], axis: key.startsWith('U') ? axis.up : axis.down };
					keys.Y.zones.push(zone);
				}
				for (let z = min.z; z <= max.z; z++) {
					let zone = { cubes: [], center: new THREE.Vector3(), angle: Math.PI/2 };

					let key = toNotation(z, min.z, max.z, 'F', 'B', 'S');
					zCoords.push([z, zone]);
					keys[key] = { zones: [zone], axis: key.startsWith('B') ? axis.back : axis.front };
					keys.Z.zones.push(zone);
				}

				let i = 0;
				for (let x = min.x; x <= max.x; x++) {
					for (let y = min.y; y <= max.y; y++) {
						for (let z = min.z; z <= max.z; z++) {
							if(x == min.x || x == max.x || y == min.y || y == max.y || z == min.z || z == max.z){
								let box = new THREE.BoxGeometry();
								let materials = [];
								for (let j = 0; j < 6; j++) {
									materials.push(getColor(j, x, y, z));
								}

								let cube = new THREE.Mesh(box, materials);

								cube.position.copy(new THREE.Vector3(x, y, z));

								for(let j = 0; j < xCoords.length; j++){
									if(xCoords[j][0] == x) {
										xCoords[j][1].cubes.push(cube.position.clone());
									}
								}
								for(let j = 0; j < yCoords.length; j++){
									if(yCoords[j][0] == y) {
										yCoords[j][1].cubes.push(cube.position.clone());
									}
								}
								for(let j = 0; j < zCoords.length; j++){
									if(zCoords[j][0] == z) {
										zCoords[j][1].cubes.push(cube.position.clone());
									}
								}

								scene.add(cube);
								cubes[i++] = cube;
							}
						}
					}
				}
			}

			function animate() {
				requestAnimationFrame(animate);
				executeQueue();
				controls.update();
				renderer.render(scene, camera);
			}

			function press(code, reverse = false) {
				if(code[0] == '#'){
					switch(code[1]){
						case '1':
							shots = [];
							if(Object.values(keys).length > 0){
								for (let i = 0; i < 40; i++) {
									addToQueue(Object.values(keys).sample(), [1, -1, 2].sample(), false);
								}
							}
							break;
						case '2':
							if(shots.length > 0){
								let shot = shots.pop();
								addToQueue(shot[0], -shot[1], false);
							}
							break;
					}
				} else {
					let direction = 1;
					if(code[code.length-1] == '\''){
						direction = -1;
						code = code.slice(0, -1);
					} else if(code[code.length-1] == '2'){
						direction = 2;
						code = code.slice(0, -1);
					}
					if(reverse){
						direction = -direction;
					}
					if(keys[code] !== undefined){
						addToQueue(keys[code], direction);
					}
				}
			}

			function addToQueue(key, direction, save = true) {
				let action = [];
				for(let zone of key.zones) {
					let group = new THREE.Group();
					scene.add(group);
					action.push({ zone: zone, direction: direction, axis: key.axis, i: 0, group: group });
				}
				if(save){
					shots.push([key, direction]);
				}
				queue.unshift(action);
			}

			function executeQueue() {
				if(queue.length > 0){
					let action = queue[queue.length-1];
					for(let singleAction of action) {

						let group = singleAction.group;
						group.position.copy(singleAction.zone.center);

						if(group.children.length == 0){

							for(let cube of cubes) {
								for(let authorizedCube of singleAction.zone.cubes) {
									let worldPosition = new THREE.Vector3();
									cube.getWorldPosition(worldPosition);
									if(worldPosition.distanceTo(authorizedCube) < 1e-10){
										group.attach(cube);
									}
								}
							}
						}

						group.rotateOnAxis(singleAction.axis, singleAction.zone.angle / speed * singleAction.direction);

						if(++singleAction.i >= speed){
							queue.pop();
							for (let children of group.children) {
								let worldPosition = new THREE.Vector3();
								children.getWorldPosition(worldPosition);
								let worldRotation = new THREE.Quaternion();
								children.getWorldQuaternion(worldRotation);
								children.parent = null;
								children.position.copy(worldPosition);
								children.quaternion.copy(worldRotation);
							}
						}
					}
				}
			}

			function updateAlgorithm() {
				let values = (urlParams.has('algo') ? urlParams.get('algo') : document.getElementById('input').value).split(' ');
				algorithm = [];
				for (let i = 0; i < values.length; i++) {
					if(values[i].length >= 1){
						let value = '';
						if('LRUDFBMESXYZ'.includes(values[i][0])){
							value = values[i][0];
							for (let j = 1; j < values[i].length-1; j++) {
								value += toIndice(values[i][j]);
							}
							if(values[i].length >= 2){
								if('\'2'.includes(values[i][values[i].length-1])){
									value += values[i][values[i].length-1];
								}
							}
						}
						algorithm.push(value);
					}
				}
				document.getElementById('algorithm').innerHTML = algorithm.join(' ');
				algorithmIndex = 0;
				algoReverse = true
			}

			function first() {
				for (let i = algorithmIndex; i >= 0; i--) {
					executeCode(true);
				}
			}

			function prec() {
				executeCode(true);
			}

			function next() {
				executeCode();
			}

			function last() {
				for (let i = algorithmIndex; i < algorithm.length; i++) {
					executeCode();
				}
			}

			function executeCode(reverse = false) {
				if(reverse && algorithmIndex > 0 || !reverse && algorithmIndex < algorithm.length-1 || algorithm.length == 1){
					if(reverse == algoReverse){
						algorithmIndex += reverse ? -1 : 1;
						algorithmIndex = Math.min(Math.max(algorithmIndex, 0), algorithm.length-1);
					}
					press(algorithm[algorithmIndex], reverse, false);
					let showAlgo = [...algorithm];
					showAlgo[algorithmIndex] = '<span id="current">'+showAlgo[algorithmIndex]+'</span>';
					document.getElementById('algorithm').innerHTML = showAlgo.join(' ');
				}
				algoReverse = reverse;
			}

			function toNotation(coord, min, max, charR, charL, charM) {
				if(coord > 0){
					return charR + toIndice(-min-coord+1);
				} else if(coord < 0){
					return charL + toIndice(max+coord+1);
				} else {
					return charM;
				}
			}

			function toIndice(number) {
				number += '';
				for (let i = 0; i <= 9; i++) {
					number = number.replaceAll(i, '₀₁₂₃₄₅₆₇₈₉'[i]);
				}
				if(number == '₁'){
					number = '';
				}
				return number;
			}

			function getColor(face, x, y, z) {

				let a = x + max.x
				let b = y + max.y;
				let l = width;
				let L = height;
				let i = '-';
				let r = 0;

				if(face == 0 && x == max.x){
					i = 'R';
					a = z + max.z;
					l = depth;
					r = 1;
				} else if(face == 1 && x == min.x){
					i = 'L';
					a = z + max.z;
					l = depth;
				} else if(face == 2 && y == max.y){
					i = 'U';
					b = z + max.z;
					L = depth;
					r = -1;
				} else if(face == 3 && y == min.y){
					i = 'D';
					b = z + max.z;
					L = depth;
				} else if(face == 4 && z == max.z){
					i = 'F';
				} else if(face == 5 && z == min.z){
					i = 'B';
					r = 1;
				} else {
					return  materialsColors['_'];
				}
				let color = colors[i][a + (L - b - 1) * l];
				if(urlParams.has('stickers')){
					let material = new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('./textures/'+urlParams.get('stickers')+'/'+color+'.png') });
					material.map.repeat.set(1/l, 1/L);
					if(r == 1){
						a = l - a - 1;
					} else if(r == -1){
						b = L - b - 1;
					}
					material.map.offset.set(a/l, b/L);
					return material;
				} else {
					return materialsColors[color];
				}
			}

			Array.prototype.sample = function(){
				return this[Math.floor(Math.random() * this.length)];
			}

			document.getElementById('btn-ok').addEventListener('click', updateAlgorithm);
			document.getElementById('btn-first').addEventListener('click', first);
			document.getElementById('btn-prec').addEventListener('click', prec);
			document.getElementById('btn-next').addEventListener('click', next);
			document.getElementById('btn-last').addEventListener('click', last);

			if(embed){
				document.getElementById('form-hide').style.display = 'none';
				if(!urlParams.has('algo')){
					document.getElementById('form').style.display = 'none';
				}
			} else {

				document.getElementById('form').onkeydown = function (e) {
					keysActive = false;
				}

				document.getElementById('input').onblur = function (e) {
					keysActive = true;
				}

				document.body.onkeydown = function (e) {
					if(keysActive){
						let key = e.key.toUpperCase();
						if('LRUDFBMESXYZ'.includes(key)) {
							press(key + acutalIndice + (e.shiftKey ? '\'' : (e.ctrlKey ? '2' : '')));
						} else if('123456789'.includes(key)) {
							acutalIndice = toIndice(key);
						} else if(key == ' ') {
							press('#1');
						} else if(key == 'BACKSPACE') {
							press('#2');
						}
						return false;
					}
				};
			}

			window.onresize = function () {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);

				controls.handleResize();
			};
		</script>
	</body>
</html>